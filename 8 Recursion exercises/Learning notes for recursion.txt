Ex_164.py
### So this was my first recursion challenge and I didn't really know how to
# think about it (recursion is famously hard to get your head around). Essentially
# you set up an 'active section of code', that will carry out the operation you
# want your function to apply, followed by a return command INCLUDING the
# function call (recursive call).
#
# This sets up a chain of operations that will not terminate until a
# 'get out clause' is executed. You can think about it as visualising the
# function call with the code of the function contained in it.
# the '[]' and '{}' is for visual aid only and do not refer to a list or
# dictionary
#
# e.g. return n + [adder()]   can be seen as...
#      return n + [n + {adder()}]     which can in turn be seen as
#      return n + [n + {n + adder()}]     This goes on and on
#
# Literally 'adder()' == 'return n + adder()'
#
# NOTICE that 'n + adder' is the last thing on the chains above. That means that
# all we need to do is give another return command that will terminate this chain
#
# e.g. return n + 0.0
#
# This will make the chain look like...
# return n + n + n + 0.0
#
# with each n being specified on each function call e.g.
# return 1.0 + 2.0 + 3.0 + 0.0
#
# this will simply return 6.0 and so job done! ###

Ex_165
### In this exercise euclid's algorithm was provided but you had to write it
# with a recursive call ###

Ex_167
### In this exercise I learned how to set default values passed to a function
# def funct(var1, var2=default_value): ###

Ex_169
### The algorithm was provided in the question and I am having a hard time
# figuring out how it determines the edit difference as it has three recursive
# calls per function which is a lot of branches on the tree ###

Ex_170
## I had to abandon this exercise as I spend three days on it and could not find
# a solution to it. I also looked on the internet and found a solution whereby
# a python library tool finds all non- repeating combinations of a set of a
# specified number (n) of variables from a set of preassigned variables
# (coin values) (so a list of every combination of n coins values) and then uses
# recursion to go through this list (using the next() function) and see if the
# specified total matches the value looked at. However, Ben explicitly said to
# not use loops and the next() command on a list is basically iterating through
# a list. I tried using tail end recursion but that did not work as function
# arguments refer to a global object and so prior variables called as arguments
# are not preserved (unlike local variable assignments in functions). ###
